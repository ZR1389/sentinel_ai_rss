from fpdf import FPDF
from datetime import date
from threat_scorer import assess_threat_level
from rss_processor import get_clean_alerts
from plan_rules import PLAN_RULES
import json
import os
from dotenv import load_dotenv
import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.application import MIMEApplication
from email.mime.text import MIMEText
from chat_handler import get_plan
from translator import translate_text
from concurrent.futures import ThreadPoolExecutor

load_dotenv()

SENDER_EMAIL = os.getenv("SENDER_EMAIL")
SENDER_PASSWORD = os.getenv("SENDER_PASSWORD")
SMTP_SERVER = os.getenv("SMTP_SERVER")
SMTP_PORT = int(os.getenv("SMTP_PORT"))

PDF_ALERT_LIMIT = 5  # Max alerts per PDF/report

def generate_translated_pdf(email, alerts, plan, language="en"):
    class PDF(FPDF):
        def header(self):
            self.set_font("Noto", "B", 16)
            self.set_text_color(237, 0, 0)
            heading = translate_text("Sentinel AI Daily Brief", target_lang=language)
            self.cell(0, 10, f"{heading} — {date.today().isoformat()}", ln=True, align='C')
            self.ln(10)

        def chapter_body(self, alerts):
            for alert in alerts:
                self.set_text_color(0)
                self.set_font("Noto", "B", 12)
                self.multi_cell(0, 10, f"{alert['title']}", align='L')

                level_color = get_threat_color(alert["level"])
                self.set_text_color(100, 100, 100)
                self.set_font("Noto", "I", 11)
                src_label = translate_text("Source", target_lang=language)
                self.cell(0, 8, f"{src_label}: {alert['source']}", ln=True)

                self.set_text_color(*level_color)
                level_label = translate_text("Threat Level", target_lang=language)
                self.cell(0, 8, f"{level_label}: {alert['level']}", ln=True)

                self.set_text_color(0)
                self.set_font("Noto", "", 12)
                self.multi_cell(0, 10, f"{alert['summary']}", align='L')

                if alert["link"]:
                    self.set_text_color(0, 0, 255)
                    self.set_font("Noto", "", 11)
                    self.cell(0, 10, alert["link"], ln=True, link=alert["link"])

                self.set_font("Noto", "", 12)
                self.set_text_color(0)
                self.ln(6)

    def get_threat_color(level):
        if level == "Low":
            return (0, 150, 0)
        elif level == "Moderate":
            return (255, 165, 0)
        elif level == "High":
            return (255, 0, 0)
        elif level == "Critical":
            return (139, 0, 0)
        else:
            return (100, 100, 100)

    # Limit number of alerts and parallelize translation
    alerts = alerts[:PDF_ALERT_LIMIT]

    titles = [alert["title"] for alert in alerts]
    summaries = [alert["summary"] for alert in alerts]

    with ThreadPoolExecutor(max_workers=5) as executor:
        translated_titles = list(executor.map(lambda t: translate_text(t, target_lang=language), titles))
        translated_summaries = list(executor.map(lambda s: translate_text(s, target_lang=language), summaries))
        threat_levels = list(executor.map(lambda tup: assess_threat_level(f"{tup[0]}: {tup[1]}"),
                                         zip(translated_titles, translated_summaries)))

    scored_alerts = []
    for i, alert in enumerate(alerts):
        scored_alerts.append({
            "title": translated_titles[i],
            "summary": translated_summaries[i],
            "source": alert["source"],
            "link": alert["link"],
            "level": threat_levels[i]
        })

    pdf = PDF()
    pdf.add_font("Noto", "", "fonts/NotoSans-Regular.ttf", uni=True)
    pdf.add_font("Noto", "B", "fonts/NotoSans-Regular.ttf", uni=True)
    pdf.add_font("Noto", "I", "fonts/NotoSans-Regular.ttf", uni=True)

    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.chapter_body(scored_alerts)

    filename = f"report_{email}_{language}_{date.today().isoformat()}.pdf"
    pdf.output(filename)
    return filename

def send_pdf_report(email, plan, language="en"):
    if not PLAN_RULES.get(plan, {}).get("pdf", False):
        raise PermissionError(f"{plan} plan does not allow PDF report access.")

    alerts = get_clean_alerts()
    pdf_file = generate_translated_pdf(email, alerts, plan, language)

    msg = MIMEMultipart()
    msg["From"] = SENDER_EMAIL
    msg["To"] = email
    msg["Subject"] = f"Sentinel AI Report — {plan} Plan"

    body = translate_text(
        f"Attached is your travel safety report generated by Sentinel AI ({plan} Plan). Stay safe and informed.",
        target_lang=language
    )
    msg.attach(MIMEText(body, "plain"))

    with open(pdf_file, "rb") as f:
        part = MIMEApplication(f.read(), Name=pdf_file)
        part['Content-Disposition'] = f'attachment; filename="{pdf_file}"'
        msg.attach(part)

    server = smtplib.SMTP(SMTP_SERVER, SMTP_PORT)
    server.starttls()
    server.login(SENDER_EMAIL, SENDER_PASSWORD)
    server.send_message(msg)
    server.quit()

    os.remove(pdf_file)
    return True

def send_daily_summaries():
    with open("clients.json", "r") as f:
        clients = json.load(f)

    for client in clients:
        email = client["email"]
        plan = client.get("plan", "FREE")
        language = client.get("lang", "en")
        try:
            if PLAN_RULES.get(plan, {}).get("pdf", False):
                send_pdf_report(email=email, plan=plan, language=language)
                print(f"Sent report to {email} ({plan}, {language})")
            else:
                print(f"Skipped {email} — no PDF access ({plan})")
        except Exception as e:
            print(f"Error sending to {email}: {str(e)}")